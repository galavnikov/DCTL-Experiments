// DCTL SCRIPT: TECHNICOLOR PROCESS (FINAL, ROBUST VERSION)
// © 2025 Gemini AI
// DEBUGGED AND OPTIMIZED ACCORDING TO OFFICIAL DAVINCI RESOLVE DOCUMENTATION

#define TIRAS3 0
#define TIRAS2 1

// --- UI DEFINITION ---
DEFINE_UI_PARAMS(techni_mode, Proceso Technicolor, DCTLUI_COMBO_BOX, 0, {tiras3, tiras2}, {3 Strips RGB, 2 strips R and Cian})
DEFINE_UI_PARAMS(show_r, Show R, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(show_g, Show G 3 tiras, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(show_b, Show B 3 tiras, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(show_c, Show Cian 2 tiras, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(bright, Density, DCTLUI_SLIDER_FLOAT, 1.0f, 0.0f, 2.0f, 0.005f)
DEFINE_UI_PARAMS(cont_master, Contrast, DCTLUI_SLIDER_FLOAT, 1.0f, 0.5f, 1.5f, 0.01f)
DEFINE_UI_PARAMS(sat, Saturation, DCTLUI_SLIDER_FLOAT, 1.0f, 0.0f, 2.0f, 0.01f)
DEFINE_UI_PARAMS(tint_general, Tint, DCTLUI_SLIDER_FLOAT, 0.0f, -180.0f, 180.0f, 0.1f)

// --- Helper Functions ---

__DEVICE__ float3 fract_f3(float3 v) {
    return make_float3(v.x - _floorf(v.x), v.y - _floorf(v.y), v.z - _floorf(v.z));
}

// NEW HELPER for vector absolute value, as _fabs() is for single floats
__DEVICE__ float3 fabs_f3(float3 v) {
    return make_float3(_fabs(v.x), _fabs(v.y), _fabs(v.z));
}

__DEVICE__ float3 rgb_to_hsv(float3 c) {
    float4 K = make_float4(0.0f, -1.0f / 3.0f, 2.0f / 3.0f, -1.0f);
    float4 p = (c.y < c.z) ? make_float4(c.z, c.y, K.w, K.z) : make_float4(c.y, c.z, K.x, K.y);
    float4 q = (c.x < p.x) ? make_float4(p.x, p.y, p.w, c.x) : make_float4(c.x, p.y, p.z, p.x);
    float d = q.x - _fminf(q.w, q.y);
    float e = 1.0e-10f;
    return make_float3(_fabs(q.z + (q.w - q.y) / (6.0f * d + e)), d / (q.x + e), q.x);
}

__DEVICE__ float3 hsv_to_rgb(float3 c) {
    float4 K = make_float4(1.0f, 2.0f / 3.0f, 1.0f / 3.0f, 3.0f);
    
    // CORREGIDO: Se utiliza la función fabs_f3() para asegurar compatibilidad
    float3 p = fabs_f3(fract_f3(make_float3(c.x, c.x, c.x) + make_float3(K.x, K.y, K.z)) * 6.0f - make_float3(K.w, K.w, K.w));
    
    float3 clamped_p = make_float3(
        _clampf(p.x - K.x, 0.0f, 1.0f),
        _clampf(p.y - K.x, 0.0f, 1.0f),
        _clampf(p.z - K.x, 0.0f, 1.0f)
    );

    return c.z * _mix(make_float3(K.x, K.x, K.x), clamped_p, c.y);
}


// --- Main Transform Function ---
__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) {
    float3 base_rgb;
    // --- PASO 1: Seleccionar el proceso base ---
    if (techni_mode == 0) {
        base_rgb = make_float3(p_R, p_G, p_B);
    } else {
        float red_comp = p_R;
        float cyan_comp = (p_G + p_B) * 0.5f;
        base_rgb = make_float3(red_comp, cyan_comp, cyan_comp);
    }

    // --- PASO 2: Aplicar Parámetros de Laboratorio ---
    float3 graded_rgb;
    graded_rgb.x = (base_rgb.x - 0.5f) * cont_master + 0.5f;
    graded_rgb.y = (base_rgb.y - 0.5f) * cont_master + 0.5f;
    graded_rgb.z = (base_rgb.z - 0.5f) * cont_master + 0.5f;
    
    float luma = graded_rgb.x * 0.2126f + graded_rgb.y * 0.7152f + graded_rgb.z * 0.0722f;
    graded_rgb.x = luma + sat * (graded_rgb.x - luma);
    graded_rgb.y = luma + sat * (graded_rgb.y - luma);
    graded_rgb.z = luma + sat * (graded_rgb.z - luma);

    graded_rgb = graded_rgb * bright;

    // --- PASO 3: Aplicar Tinte General ---
    if (tint_general != 0.0f) {
        float3 hsv = rgb_to_hsv(graded_rgb);
        hsv.x = hsv.x + tint_general / 360.0f;
        hsv.x = hsv.x - _floorf(hsv.x);
        graded_rgb = hsv_to_rgb(hsv);
    }
    
    // --- PASO 4: Aplicar Aislamiento de Canales ---
    float3 final_rgb = graded_rgb;
    if (techni_mode == 0) {
        if (show_r == 0) { final_rgb.x = 0.0f; }
        if (show_g == 0) { final_rgb.y = 0.0f; }
        if (show_b == 0) { final_rgb.z = 0.0f; }
    } else {
        if (show_r == 0) { final_rgb.x = 0.0f; }
        if (show_c == 0) {
            final_rgb.y = 0.0f;
            final_rgb.z = 0.0f;
        }
    }
    
    // --- PASO 5: Devolver el resultado final ---
    return final_rgb;
}